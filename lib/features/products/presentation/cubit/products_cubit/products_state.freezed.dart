// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'products_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ProductsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProductsStateCopyWith<$Res> {
  factory $ProductsStateCopyWith(
          ProductsState value, $Res Function(ProductsState) then) =
      _$ProductsStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ProductsStateCopyWithImpl<$Res>
    implements $ProductsStateCopyWith<$Res> {
  _$ProductsStateCopyWithImpl(this._value, this._then);

  final ProductsState _value;
  // ignore: unused_field
  final $Res Function(ProductsState) _then;
}

/// @nodoc
abstract class _$InitCopyWith<$Res> {
  factory _$InitCopyWith(_Init value, $Res Function(_Init) then) =
      __$InitCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitCopyWithImpl<$Res> extends _$ProductsStateCopyWithImpl<$Res>
    implements _$InitCopyWith<$Res> {
  __$InitCopyWithImpl(_Init _value, $Res Function(_Init) _then)
      : super(_value, (v) => _then(v as _Init));

  @override
  _Init get _value => super._value as _Init;
}

/// @nodoc

class _$_Init implements _Init {
  _$_Init();

  @override
  String toString() {
    return 'ProductsState.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Init);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements ProductsState {
  factory _Init() = _$_Init;
}

/// @nodoc
abstract class $ProductsLoadingCopyWith<$Res> {
  factory $ProductsLoadingCopyWith(
          ProductsLoading value, $Res Function(ProductsLoading) then) =
      _$ProductsLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$ProductsLoadingCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res>
    implements $ProductsLoadingCopyWith<$Res> {
  _$ProductsLoadingCopyWithImpl(
      ProductsLoading _value, $Res Function(ProductsLoading) _then)
      : super(_value, (v) => _then(v as ProductsLoading));

  @override
  ProductsLoading get _value => super._value as ProductsLoading;
}

/// @nodoc

class _$ProductsLoading implements ProductsLoading {
  _$ProductsLoading();

  @override
  String toString() {
    return 'ProductsState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ProductsLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ProductsLoading implements ProductsState {
  factory ProductsLoading() = _$ProductsLoading;
}

/// @nodoc
abstract class _$DoneCopyWith<$Res> {
  factory _$DoneCopyWith(_Done value, $Res Function(_Done) then) =
      __$DoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$DoneCopyWithImpl<$Res> extends _$ProductsStateCopyWithImpl<$Res>
    implements _$DoneCopyWith<$Res> {
  __$DoneCopyWithImpl(_Done _value, $Res Function(_Done) _then)
      : super(_value, (v) => _then(v as _Done));

  @override
  _Done get _value => super._value as _Done;
}

/// @nodoc

class _$_Done implements _Done {
  _$_Done();

  @override
  String toString() {
    return 'ProductsState.done()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Done);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) {
    return done();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) {
    return done?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) {
    if (done != null) {
      return done();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) {
    return done(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) {
    return done?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) {
    if (done != null) {
      return done(this);
    }
    return orElse();
  }
}

abstract class _Done implements ProductsState {
  factory _Done() = _$_Done;
}

/// @nodoc
abstract class _$productDoneCopyWith<$Res> {
  factory _$productDoneCopyWith(
          _productDone value, $Res Function(_productDone) then) =
      __$productDoneCopyWithImpl<$Res>;
  $Res call({Product product});

  $ProductCopyWith<$Res> get product;
}

/// @nodoc
class __$productDoneCopyWithImpl<$Res> extends _$ProductsStateCopyWithImpl<$Res>
    implements _$productDoneCopyWith<$Res> {
  __$productDoneCopyWithImpl(
      _productDone _value, $Res Function(_productDone) _then)
      : super(_value, (v) => _then(v as _productDone));

  @override
  _productDone get _value => super._value as _productDone;

  @override
  $Res call({
    Object? product = freezed,
  }) {
    return _then(_productDone(
      product: product == freezed
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Product,
    ));
  }

  @override
  $ProductCopyWith<$Res> get product {
    return $ProductCopyWith<$Res>(_value.product, (value) {
      return _then(_value.copyWith(product: value));
    });
  }
}

/// @nodoc

class _$_productDone implements _productDone {
  _$_productDone({required this.product});

  @override
  final Product product;

  @override
  String toString() {
    return 'ProductsState.productDone(product: $product)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _productDone &&
            const DeepCollectionEquality().equals(other.product, product));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(product));

  @JsonKey(ignore: true)
  @override
  _$productDoneCopyWith<_productDone> get copyWith =>
      __$productDoneCopyWithImpl<_productDone>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) {
    return productDone(product);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) {
    return productDone?.call(product);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) {
    if (productDone != null) {
      return productDone(product);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) {
    return productDone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) {
    return productDone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) {
    if (productDone != null) {
      return productDone(this);
    }
    return orElse();
  }
}

abstract class _productDone implements ProductsState {
  factory _productDone({required final Product product}) = _$_productDone;

  Product get product => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$productDoneCopyWith<_productDone> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ErrorCopyWith<$Res> {
  factory _$ErrorCopyWith(_Error value, $Res Function(_Error) then) =
      __$ErrorCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$ErrorCopyWithImpl<$Res> extends _$ProductsStateCopyWithImpl<$Res>
    implements _$ErrorCopyWith<$Res> {
  __$ErrorCopyWithImpl(_Error _value, $Res Function(_Error) _then)
      : super(_value, (v) => _then(v as _Error));

  @override
  _Error get _value => super._value as _Error;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_Error(
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Error implements _Error {
  _$_Error({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'ProductsState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Error &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$ErrorCopyWith<_Error> get copyWith =>
      __$ErrorCopyWithImpl<_Error>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements ProductsState {
  factory _Error({required final String error}) = _$_Error;

  String get error => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ErrorCopyWith<_Error> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ProductErrorCopyWith<$Res> {
  factory _$ProductErrorCopyWith(
          _ProductError value, $Res Function(_ProductError) then) =
      __$ProductErrorCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$ProductErrorCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res>
    implements _$ProductErrorCopyWith<$Res> {
  __$ProductErrorCopyWithImpl(
      _ProductError _value, $Res Function(_ProductError) _then)
      : super(_value, (v) => _then(v as _ProductError));

  @override
  _ProductError get _value => super._value as _ProductError;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_ProductError(
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ProductError implements _ProductError {
  _$_ProductError({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'ProductsState.productError(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ProductError &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$ProductErrorCopyWith<_ProductError> get copyWith =>
      __$ProductErrorCopyWithImpl<_ProductError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() done,
    required TResult Function(Product product) productDone,
    required TResult Function(String error) error,
    required TResult Function(String error) productError,
  }) {
    return productError(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
  }) {
    return productError?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? done,
    TResult Function(Product product)? productDone,
    TResult Function(String error)? error,
    TResult Function(String error)? productError,
    required TResult orElse(),
  }) {
    if (productError != null) {
      return productError(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(ProductsLoading value) loading,
    required TResult Function(_Done value) done,
    required TResult Function(_productDone value) productDone,
    required TResult Function(_Error value) error,
    required TResult Function(_ProductError value) productError,
  }) {
    return productError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
  }) {
    return productError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(ProductsLoading value)? loading,
    TResult Function(_Done value)? done,
    TResult Function(_productDone value)? productDone,
    TResult Function(_Error value)? error,
    TResult Function(_ProductError value)? productError,
    required TResult orElse(),
  }) {
    if (productError != null) {
      return productError(this);
    }
    return orElse();
  }
}

abstract class _ProductError implements ProductsState {
  factory _ProductError({required final String error}) = _$_ProductError;

  String get error => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ProductErrorCopyWith<_ProductError> get copyWith =>
      throw _privateConstructorUsedError;
}
